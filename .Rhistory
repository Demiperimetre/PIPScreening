sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x1
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
expect_length(resmcmc$MH$chain[,1],nMet)
expect_length(resmcmc$MH$chain[1,],pgamma+2)
ptheta <- 3
parwalkinit2 <- c(rep(.1,pgamma),.1,.1,rep(.1,ptheta))
init2 <- c(rep(0,pgamma),.004,.2,rep(.5,ptheta))
resmcmccal <- MCMC(nMWG,nMet,parwalkinit2,init2,Rexp,tdistFULL,1.9,parprior,TRUE,calibration2)
expect_length(resmcmccal$MH$chain[,1],nMet)
expect_length(resmcmccal$MH$chain[1,],pgamma+2+ptheta)
Rcpp::sourceCpp('src/utils.cpp')
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
expect_length(resmcmc$MH$chain[,1],nMet)
expect_length(resmcmc$MH$chain[1,],pgamma+2)
ptheta <- 3
parwalkinit2 <- c(rep(.1,pgamma),.1,.1,rep(.1,ptheta))
init2 <- c(rep(0,pgamma),.004,.2,rep(.5,ptheta))
resmcmccal <- MCMC(nMWG,nMet,parwalkinit2,init2,Rexp,tdistFULL,1.9,parprior,TRUE,calibration2)
resmcmccal[,1]
resmcmccal$MH[,1]
resmcmccal$MH$chain[1,]
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
expect_length(resmcmc$MH$chain[,1],nMet)
expect_length(resmcmc$MH$chain[1,],pgamma+2)
ptheta <- 3
parwalkinit2 <- c(rep(.1,pgamma),.1,.1,rep(.1,ptheta))
init2 <- c(rep(0,pgamma),.004,.2,rep(.5,ptheta))
resmcmccal <- MCMC(nMWG,nMet,parwalkinit2,init2,Rexp,tdistFULL,1.9,parprior,TRUE,calibration2)
resmcmccal$MH$chain[1,]
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
expect_length(resmcmc$MH$chain[,1],nMet)
expect_length(resmcmc$MH$chain[1,],pgamma+2)
ptheta <- 3
parwalkinit2 <- c(rep(.1,pgamma),.1,.1,rep(.1,ptheta))
init2 <- c(rep(0,pgamma),.004,.2,rep(.5,ptheta))
resmcmccal <- MCMC(nMWG,nMet,parwalkinit2,init2,Rexp,tdistFULL,1.9,parprior,TRUE,calibration2)
resmcmccal$MH$chain[1,]
expect_length(resmcmccal$MH$chain[,1],nMet)
Rcpp::sourceCpp('src/utils.cpp')
library(PIPScreening)
devtools::load_all(".")
Rcpp::sourceCpp('src/utils.cpp')
use_rcpp()
devtools::load_all(".")
use_rcpp_armadillo()
library(PIPScreening)
library(testthat)
library(devtools)
library(usethis)
library(PIPScreening)
covr::package_coverage() # test
document() #generer les doc
load_all() # pour charger les fonctinos
document() #generer les doc
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
covr::report() # pour avoir le rapport
covr::report() # pour avoir le rapport
document() #generer les doc
covr::report() # pour avoir le rapport
covr::report() # pour avoir le rapport
covr::package_coverage() # test
covr::report() # pour avoir le rapport
covr::report() # pour avoir le rapport
covr::report() # pour avoir le rapport
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
covr::package_coverage() # test
load_all() # pour charger les fonctinos
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
document() #generer les doc
load_all() # pour charger les fonctinos
document() #generer les doc
Rcpp::compileAttributes()
document() #generer les doc
document() #generer les doc
test() # bug si on ne refait pas un buil ?
load_all() # pour charger les fonctinos
test() # bug si on ne refait pas un buil ?
test() # bug si on ne refait pas un buil ?
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
expect_length(resmcmc$MH$chain[,1],nMet)
expect_length(resmcmc$MH$chain[1,],pgamma+2)
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
library(PIPScreening)
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
Rcpp::sourceCpp('src/functionsMCMC.cpp')
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
Rcpp::sourceCpp('src/functionsMCMC.cpp')
devtools::load_all(".")
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
library(PIPScreening)
View(MCMC)
View(MetropoliswGibbs)
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
Rcpp::sourceCpp('src/functionsMCMC.cpp')
library(PIPScreening)
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
Rcpp::sourceCpp('src/functionsMCMC.cpp')
library(PIPScreening)
library(PIPScreening)
library(testthat)
library(devtools)
library(usethis)
library(PIPScreening)
#use_test("utils.cpp")
use_test("BridgeIS")
ech = matrix(runif(100),20,5)
load_all() # pour charger les fonctinos
document() #generer les doc
BFbridgeIS(ech,gamma=rep(100,5))
BFbridgeIS(ech,gamma=rep(100,5))
library(PIPScreening)
BFbridgeIS(ech,gamma=rep(100,5))
library(PIPScreening)
BFbridgeIS(ech,gamma=rep(100,5))
library(PIPScreening)
BFbridgeIS(ech,gamma=rep(100,5))
load_all() # pour charger les fonctinos
document() #generer les doc
library(PIPScreening)
BFbridgeIS(ech,gamma=rep(100,5))
library(PIPScreening)
load_all() # pour charger les fonctinos
document() #generer les doc
library(PIPScreening)
valmax = 100 # param
GAMMA = expand.grid(c(1,valmax),c(1,valmax),c(1,valmax),c(1,valmax),c(1,valmax))
GAMMA = expand.grid(c(1,valmax),c(1,valmax),c(1,valmax),c(1,valmax),c(1,valmax)) # comment faire expand.grid generique ?
BFall = sapply(1:nrow(GAMMA),function(k) {
BFbridge(ech,gamma = as.numeric(GAMMA[k,]))})
BFall = sapply(1:nrow(GAMMA),function(k) {
BFbridgeIS(ech,gamma = as.numeric(GAMMA[k,]))})
BFall
BFall
for (i in 1:5)
{
IndicVar[i,] = (GAMMA[,i]==1)*1
}
IndicVar = matrix(NA,nrow = 5, ncol = 2^5)
for (i in 1:5)
{
IndicVar[i,] = (GAMMA[,i]==1)*1
}
prob = IndicVar %*% a / matrix(colSums(a),nrow=5,ncol=100,byrow = T)
prob = IndicVar %*% BFall / matrix(colSums(BFall),nrow=5,ncol=100,byrow = T)
IndicVar = matrix(NA,nrow = 5, ncol = 2^5)
for (i in 1:5)
{
IndicVar[i,] = (GAMMA[,i]==1)*1
}
a=BFall
IndicVar
BFall
IndicVar %*% a
sum(a)
prob = IndicVar %*% a / sum(a)
prob
ech
expand.grid(replicate(3, v, simplify=FALSE))
expand.grid(replicate(3, 2, simplify=FALSE))
expand.grid(replicate(3, c(1,valmax), simplify=FALSE))
expand.grid(replicate(5, c(1,valmax), simplify=FALSE))
expand.grid(replicate(5, c(1,valmax), simplify=FALSE))==GAMMA
prob
as.vector(prob)
library(PIPScreening)
library(PIPScreening)
set.seed(1)
ech <- runif(100)
echlogit <- matrix(log(ech/(1+ech)),20,5)
expect_equal( computeProbActive(echlogit) ,rep(1,5))
computeProbActive(echlogit)
rep(1,5)
load_all() # pour charger les fonctinos
document() #generer les doc
load_all() # pour charger les fonctinos
test() # bug si on ne refait pas un buil ?
covr::package_coverage() # test
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
devtools::load_all(".")
library(PIPScreening)
?MetropoliswGibbs
Rcpp::sourceCpp('src/functionsMCMC.cpp')
load_all() # pour charger les fonctinos
document() #generer les doc
devtools::load_all(".")
library(PIPScreening)
library(PIPScreening)
library(PIPScreening)
Sys.sleep(1)
library(sbm)
devtools::install_github("GrossSBM/sbm",ref="multipartite")
library(sbm)
library(sbm)
?estimateMu
?estimateMultipartiteSBM
devtools::install_github("GrossSBM/sbm",ref="multipartite")
devtools::install_github("GrossSBM/sbm",ref="multipartite",force = TRUE)
library(sbm)
?estimateMultipartiteSBM
?estimateBipartiteSBM
pkgdown::build_articles()
library(PIPScreening)
pkgdown::build_articles()
library(stringi)
detach("package:stringi", unload = TRUE)
install.packages("stringi")
library(PIPScreening)
pkgdown::build_articles()
library(PIPScreening)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(PIPScreening)
N<-50
beta<-c(1,0,1,0,0) # binary vectors indicating which input variables x are used in the physical simulator (1) or not (0)
theta<-4:8/10 # choice of the theta (here same size as x)
sd<-0.05
p <- c(2,1,1,1,1) # power for the x's
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5])
mu <- simGal(covargal,theta,beta) # physical system
y <- mu + rnorm(N,0,sd) # field exp by adding noise
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mod <- sim3(x, theta[1:3]) # output of computer model
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T) # normalization
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
parprior <- rbind(matrix(1,nrow=pgamma,ncol=2),c(4,.02),c(3,1))
nMWG <- 200
nMet <- 200
resmcmc <- (MCMC(nMWG,nMet,parwalkinit,init,Rexp,tdistFULL,1.9,parprior,TRUE,calibration1))
parwalkinit
init
# test comme scenarii papier
set.seed(1)
N=50
beta=c(1,0,1,0,0)
theta=4:8/10
sd=0.05
non.linear = c(2,1,1,1,1)
x1 <- runif(N,0,1)
x2 <- runif(N,0,1)
x3 <- runif(N,0,1)
x4 <- runif(N,0,1)
x5 <- x3 + rnorm(N,sd=.2)
p <- non.linear
covargal <- cbind(x1^p[1],x2^p[2],x3^p[3],x4^p[4],x5^p[5]) # reality cov
x <- cbind(x1,x2,x3,x4,x5)
covarmod <- cbind(x1,x2,x3) # model covariates
mu <- simGal(covargal,theta,beta)
y <- mu + rnorm(N,0,sd) # field exp
mod <- sim3(x, theta[1:3])
xnorm <- (x - matrix(apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T))/matrix(apply(x,2,max)-apply(x,2,min),nrow=nrow(x),ncol=ncol(x),byrow=T)
Yexp <- y; Xexpnorm <- xnorm; Xexp <- x;  Rexp <- (y-mod)
calibration1 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,FALSE)
calibration2 <- list(computermodel=sim3,Yexp=Yexp,Xexp=Xexp,TRUE)
tdistFULL <- tensordist(xnorm)
pgamma <-  5
parwalkinit  <-  c(rep(.1,pgamma),.1,.1)
init  <-  c(rep(0,pgamma),.004,.2)
a <- TRUE
cpt <- 0
